<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\gameobjects\tilemap\TIleMapLayer.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABB.html">AABB</a></li>
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/AnimationManager.html">AnimationManager</a></li>
            
                <li><a href="../classes/ArcadePhysics.html">ArcadePhysics</a></li>
            
                <li><a href="../classes/Audio.html">Audio</a></li>
            
                <li><a href="../classes/AudioLibrary.html">AudioLibrary</a></li>
            
                <li><a href="../classes/AudioManager.html">AudioManager</a></li>
            
                <li><a href="../classes/Back.html">Back</a></li>
            
                <li><a href="../classes/Bar.html">Bar</a></li>
            
                <li><a href="../classes/BasicScore.html">BasicScore</a></li>
            
                <li><a href="../classes/Bootstrap.html">Bootstrap</a></li>
            
                <li><a href="../classes/Bounce.html">Bounce</a></li>
            
                <li><a href="../classes/Box.html">Box</a></li>
            
                <li><a href="../classes/Browser.html">Browser</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraManager.html">CameraManager</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/CanvasRenderer.html">CanvasRenderer</a></li>
            
                <li><a href="../classes/Circle.html">Circle</a></li>
            
                <li><a href="../classes/Circular.html">Circular</a></li>
            
                <li><a href="../classes/Clock.html">Clock</a></li>
            
                <li><a href="../classes/ClockManager.html">ClockManager</a></li>
            
                <li><a href="../classes/Common.html">Common</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/ComponentManager.html">ComponentManager</a></li>
            
                <li><a href="../classes/Counter.html">Counter</a></li>
            
                <li><a href="../classes/Cubic.html">Cubic</a></li>
            
                <li><a href="../classes/DataLibrary.html">DataLibrary</a></li>
            
                <li><a href="../classes/Device.html">Device</a></li>
            
                <li><a href="../classes/Elastic.html">Elastic</a></li>
            
                <li><a href="../classes/Entity.html">Entity</a></li>
            
                <li><a href="../classes/Exponential.html">Exponential</a></li>
            
                <li><a href="../classes/File.html">File</a></li>
            
                <li><a href="../classes/FileStore.html">FileStore</a></li>
            
                <li><a href="../classes/Finger.html">Finger</a></li>
            
                <li><a href="../classes/Game.html">Game</a></li>
            
                <li><a href="../classes/GameManager.html">GameManager</a></li>
            
                <li><a href="../classes/GameMath.html">GameMath</a></li>
            
                <li><a href="../classes/GLArrayBuffer.html">GLArrayBuffer</a></li>
            
                <li><a href="../classes/GLElementArrayBuffer.html">GLElementArrayBuffer</a></li>
            
                <li><a href="../classes/GLRenderer.html">GLRenderer</a></li>
            
                <li><a href="../classes/GLShaders.html">GLShaders</a></li>
            
                <li><a href="../classes/GLTexture.html">GLTexture</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/HUDDisplay.html">HUDDisplay</a></li>
            
                <li><a href="../classes/HUDManager.html">HUDManager</a></li>
            
                <li><a href="../classes/HUDWidget.html">HUDWidget</a></li>
            
                <li><a href="../classes/IChild.html">IChild</a></li>
            
                <li><a href="../classes/Icon.html">Icon</a></li>
            
                <li><a href="../classes/IconCounter.html">IconCounter</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/InputManager.html">InputManager</a></li>
            
                <li><a href="../classes/Intersect.html">Intersect</a></li>
            
                <li><a href="../classes/IntersectResult.html">IntersectResult</a></li>
            
                <li><a href="../classes/Key.html">Key</a></li>
            
                <li><a href="../classes/Keyboard.html">Keyboard</a></li>
            
                <li><a href="../classes/Keycodes.html">Keycodes</a></li>
            
                <li><a href="../classes/Line.html">Line</a></li>
            
                <li><a href="../classes/Linear.html">Linear</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/MasterClock.html">MasterClock</a></li>
            
                <li><a href="../classes/Matrix.html">Matrix</a></li>
            
                <li><a href="../classes/Menu.html">Menu</a></li>
            
                <li><a href="../classes/MenuItem.html">MenuItem</a></li>
            
                <li><a href="../classes/Mouse.html">Mouse</a></li>
            
                <li><a href="../classes/MouseCursor.html">MouseCursor</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Pointer.html">Pointer</a></li>
            
                <li><a href="../classes/Quadratic.html">Quadratic</a></li>
            
                <li><a href="../classes/Quartic.html">Quartic</a></li>
            
                <li><a href="../classes/Quintic.html">Quintic</a></li>
            
                <li><a href="../classes/RandomDataGenerator.html">RandomDataGenerator</a></li>
            
                <li><a href="../classes/Range.html">Range</a></li>
            
                <li><a href="../classes/Ray.html">Ray</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/RequestAnimationFrame.html">RequestAnimationFrame</a></li>
            
                <li><a href="../classes/Sequence.html">Sequence</a></li>
            
                <li><a href="../classes/Signal.html">Signal</a></li>
            
                <li><a href="../classes/SignalBinding.html">SignalBinding</a></li>
            
                <li><a href="../classes/SingleImage.html">SingleImage</a></li>
            
                <li><a href="../classes/Sinusoidal.html">Sinusoidal</a></li>
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a href="../classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="../classes/Stage.html">Stage</a></li>
            
                <li><a href="../classes/State.html">State</a></li>
            
                <li><a href="../classes/StateConfig.html">StateConfig</a></li>
            
                <li><a href="../classes/StateManager.html">StateManager</a></li>
            
                <li><a href="../classes/StaticImage.html">StaticImage</a></li>
            
                <li><a href="../classes/TextField.html">TextField</a></li>
            
                <li><a href="../classes/Textfield.html">Textfield</a></li>
            
                <li><a href="../classes/TextureAtlas.html">TextureAtlas</a></li>
            
                <li><a href="../classes/TextureLibrary.html">TextureLibrary</a></li>
            
                <li><a href="../classes/Tile.html">Tile</a></li>
            
                <li><a href="../classes/TileMap.html">TileMap</a></li>
            
                <li><a href="../classes/TileMapLayer.html">TileMapLayer</a></li>
            
                <li><a href="../classes/TileType.html">TileType</a></li>
            
                <li><a href="../classes/Time.html">Time</a></li>
            
                <li><a href="../classes/Timer.html">Timer</a></li>
            
                <li><a href="../classes/TimerEvent.html">TimerEvent</a></li>
            
                <li><a href="../classes/Touch.html">Touch</a></li>
            
                <li><a href="../classes/Transform.html">Transform</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/TweenManager.html">TweenManager</a></li>
            
                <li><a href="../classes/Vector2.html">Vector2</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animations.html">Animations</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Easing.html">Easing</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/HUD.html">HUD</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Renderers.html">Renderers</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
                <li><a href="../modules/Widget.html">Widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\gameobjects\tilemap\TIleMapLayer.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Kiwi - GameObjects - TileMapLayer
* @module GameObjects
* @submodule Tilemap
* 
*/

module Kiwi.GameObjects.Tilemap {

    /**
    *
    * @class TileMapLayer
    * @extends Entity
    * @constructor
    * @param state {State} The state that this tilemap belongs to. 
    * @param parent {TileMap} The TileMap on which this TileMapLayer is a part of.
    * @param atlas {SpriteSheet} The spritesheet that is being used to render the tiles.
    * @param name {string} The name of this tilemap.
    * @param tileWidth {number} The width of a single tile.
    * @param tileHeight {number} The height of a single tile
    * @return {TileMapLayer} 
    * 
    */
    export class TileMapLayer extends Kiwi.Entity {
         
        constructor(state:Kiwi.State, parent: Kiwi.GameObjects.Tilemap.TileMap, atlas: Kiwi.Textures.SpriteSheet, name: string, tileWidth: number, tileHeight: number) {
            
            super(state,0,0);

            this.tileParent = parent;

            this.name = name;
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;

            this.mapData = [];
            this._tempTileBlock = [];
            this._atlas = atlas;
           
        }

        /**
        * The TileMap that this TileMapLayer is a child of.
        * @property tileParent
        * @type TileMap
        * @public
        */
        public tileParent: Kiwi.GameObjects.Tilemap.TileMap;

        /**
        * The spritesheet that is being used to render information on.
        * @property _atlas
        * @type SpriteSheet
        * @private
        */
        private _atlas: Kiwi.Textures.SpriteSheet;

        /**
        * The starting tile on the x axis (the row) that needs to rendered. 
        * This is calculated based upon where the tiles are in relation to the camera.
        * This is updated each frame.
        * @property _startX
        * @type number
        * @private
        */
        private _startX: number = 0;
        
        /**
        * The starting tile on the y axis (the column) that needs to rendered. 
        * This is calculated based upon where the tiles are in relation to the camera.
        * This is updated each frame.
        * @property _startY
        * @type number
        * @private
        */
        private _startY: number = 0;

        /**
        * The maximum number of tiles that can fit on the camera. On the x axis. From this we can calculate the last tile we need to render.
        * @property _maxX
        * @type number
        * @private
        */
        private _maxX: number = 0;

        /**
        * The maximum number of tiles that can fit on the camera. On the y axis. From this we can calculate the last tile we need to render.
        * @property _maxY
        * @type number
        * @private
        */
        private _maxY: number = 0;

        /**
        * Temporarily holds the information for a single column on tiles.
        * @property _columnData
        * @type Object
        * @private
        */
        private _columnData;

        /**
        * Holds a set of tile information that is temporarily used when manipulating tiles. 
        * @property _tempTileBlock
        * @type Any
        * @private
        */
        private _tempTileBlock;

        /**
        * Holds the starting index of a tile on the x-axis that are to be retrieved. 
        * Use with the other _tempTile properties.
        * @property _tempTileX
        * @type number
        * @private
        */
        private _tempTileX: number;

        /**
        * Holds the starting index of a tile on the y-axis that are to be retrieved.
        * Use with the other _tempTile properties.
        * @property _tempTileY
        * @type number
        * @private
        */
        private _tempTileY: number;

        /**
        * Holds the number of tiles in the x-axis that are to be retrieved.
        * Use with the other _tempTile properties.
        * @property _tempTileW
        * @type number
        * @private
        */
        private _tempTileW: number;

        /**
        * Holds the number of tiles in the y-axis that are to be retrieved.
        * Use with the other _tempTile properties.
        * @property _tempTileH
        * @type number
        * @private
        */
        private _tempTileH: number;

        /**
        * The name of the layer. This is never used so it can just be for niceties.
        * @property name
        * @type string
        * @public
        */
        public name: string;

        /**
        * Holds all of the information about the tile map data.
        * @property mapData
        * @type Array
        * @public
        */
        public mapData;

        /**
        * The width of a single tile. This is the same across tiles.
        * @property tileWidth
        * @type number
        * @public
        */
        public tileWidth: number;
        
        /**
        * The height of a single tile. This is the same across tiles.
        * @property tileHeight
        * @type number
        * @public
        */
        public tileHeight: number;

        /**
        * The number of tiles on the x-axis for this TileMapLayer.
        * @property widthInTiles
        * @type number
        * @public
        */
        public widthInTiles: number = 0;
        
        /**
        * The number of tile on the y-axis for the TileMapLayer.
        * @property heightInTiles
        * @type number
        * @public
        */
        public heightInTiles: number = 0;

        /**
        * The width of the whole TileMapLayer in pixels.
        * @property widthInPixels
        * @type number
        * @public
        */
        public widthInPixels: number = 0;
        
        /**
        * The height of the while TileMapLayer in pixels.
        * @property heightInPixels
        * @type number
        * @public
        */
        public heightInPixels: number = 0;

        /**
        * Adds a single tile to the map at the given boundaries. This could be used to override a currently existing map tile.
        *
        * @method putTile
        * @param x {number} The x coordinate of the tile.
        * @param y {number} The y coordinate of the tile.
        * @param tileType {TileType} The type of tile that you are adding.
        * @public
        */
        public putTile(x: number, y: number, tileType: Kiwi.GameObjects.Tilemap.TileType) {

            x = Kiwi.Utils.GameMath.snapToFloor(x, this.tileWidth) / this.tileWidth;
            y = Kiwi.Utils.GameMath.snapToFloor(y, this.tileHeight) / this.tileHeight;

            if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length) {
                if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length) {
                    this.mapData[y][x].tileUpdate(tileType);
                }
            }

        }

        /**
        * Replaces a section of tiles on the map with a particular tile. [NEEDS UPDATING]
        * 
        * @method fillTile
        * @param index {number} The type of tile that you are using.
        * @param [x=0] {number} The starting coordinate of the tile on the x-axis. 
        * @param [y=0] {number} The starting coordinate of the tile on the y-axis.
        * @param [width] {number} The width of the area you want to replace. Defaults to the whole maps width.
        * @param [height] {number} The height of the area you want to replace. Defaults to the whole maps height.
        * @public
        */
        public fillTiles(index: number, x: number = 0, y: number = 0, width: number = this.widthInTiles, height: number = this.heightInTiles) {

            this.getTempBlock(x, y, width, height); 

            for (var r = 0; r &lt; this._tempTileBlock.length; r++) {
                this.mapData[this._tempTileBlock[r].ty][this._tempTileBlock[r].tx].tileUpdate(this.tileParent.tiles[index]);
            }

        }

        /**
        * Randomises a section of tiles on the map based on the tiles you want there.
        *
        * @method randomiseTiles
        * @param tiles {number[]} An array consisting of the TileTypes that you want.
        * @param [x=0] {number} The starting coordinate of the tile on the x-axis. 
        * @param [y=0] {number} The starting coordinate of the tile on the y-axis.
        * @param [width] {number} The width of the area you want to replace. Defaults to the whole maps width.
        * @param [height] {number} The height of the area you want to replace. Defaults to the whole maps height.
        * @public
        */
        public randomiseTiles(tiles: number[], x: number= 0, y: number = 0, width: number= this.widthInTiles, height: number= this.heightInTiles) {
            
            this.getTempBlock(x, y, width, height);

            for (var r = 0; r &lt; this._tempTileBlock.length; r++) {
                this.mapData[this._tempTileBlock[r].ty][this._tempTileBlock[r].tx].tileUpdate(this.tileParent.tiles[this.game.rnd.pick(tiles)]);
            }
        } 

        /**
        * Swaps all of the tiles of indexA with tiles of indexB and the same alternatively.
        * 
        * @method swapTiles
        * @param indexA {number} The first type of tile you want to swapped with indexB.
        * @param indexB {number} The second type of tile that is to be swapped with indexA.
        * @param [x=0] {number} The starting coordinate of the tile on the x-axis. 
        * @param [y=0] {number} The starting coordinate of the tile on the y-axis.
        * @param [width] {number} The width of the area you want to replace. Defaults to the whole maps width.
        * @param [height] {number} The height of the area you want to replace. Defaults to the whole maps height.
        * @public
        */
        public swapTiles(indexA: number, indexB: number, x: number = 0, y: number = 0, width: number= this.widthInTiles, height: number= this.heightInTiles) {

            this.getTempBlock(x, y, width, height);

            for (var r = 0; r &lt; this._tempTileBlock.length; r++) {

                if (this._tempTileBlock[r].tileType.index === indexA) {
                    this.mapData[this._tempTileBlock[r].ty][this._tempTileBlock[r].tx].tileUpdate(this.tileParent.tiles[indexB]);

                } else if (this._tempTileBlock[r].tileType.index === indexB) {
                    this.mapData[this._tempTileBlock[r].ty][this._tempTileBlock[r].tx].tileUpdate(this.tileParent.tiles[indexA]);
                }

            }

        }

        /**
        * Replaces all of the tiles of indexA with the tiles of indexB. This only happen&#x27;s one way.
        *
        * @method replaceTiles
        * @param indexA {number} The tile type that you want to be replaced.
        * @param indexB {number} The tile type that you want to replace it with. 
        * @param [x=0] {number} The starting coordinate of the tile on the x-axis. 
        * @param [y=0] {number} The starting coordinate of the tile on the y-axis.
        * @param [width] {number} The width of the area you want to replace. Defaults to the whole maps width.
        * @param [height] {number} The height of the area you want to replace. Defaults to the whole maps height.
        * @public
        */ 
        public replaceTiles(indexA: number, indexB: number, x: number = 0, y: number = 0, width: number = this.widthInTiles, height: number= this.heightInTiles) {
            this.getTempBlock(x, y, width, height);

            for (var r = 0; r &lt; this._tempTileBlock.length; r++) {

                if (this._tempTileBlock[r].tileType.index === indexA) {
                    this.mapData[this._tempTileBlock[r].ty][this._tempTileBlock[r].tx].tileUpdate(this.tileParent.tiles[indexB]);
                }

            }
        }

        /**
        * Gets a single tile from the x and y provided.
        * 
        * @method getTileFromWorldXY
        * @param x {number} The coordinate of the tile on the x axis.
        * @param y {number} The coordinate of the tile on the y axis.
        * @return {Tile} The tile that is at the coordinates if there was one.
        * @public
        */
        public getTileFromXY(x: number, y: number): Kiwi.GameObjects.Tilemap.Tile {

            x = Kiwi.Utils.GameMath.snapToFloor(((x - this.transform.worldX )), this.tileWidth) / this.tileWidth;
            y = Kiwi.Utils.GameMath.snapToFloor(((y - this.transform.worldY )), this.tileHeight) / this.tileHeight;

            return this.getTile(x, y);

        }

        /**
        * Gets all of the tiles by the index number you pass. 
        *
        * @method getTilesByIndex
        * @param {number} The index of the types of tiles you want to retrieve.
        * @return {Tile[]}
        * @public
        */
        public getTilesByIndex(index: number):Tile[] {
            var tiles = [];
            for (var ty = 0; ty &lt; this.mapData.length; ty++) {
                for (var tx = 0; tx &lt; this.mapData[ty].length; tx++) {

                    if (this.mapData[ty][tx].tileType.index === index) {
                        tiles.push(this.mapData[ty][tx]);
                    }

                }
            }
            return tiles;
        }

        /**
        * Creates a set of temporary tile blocks based on the current map data.
        * Perhaps add another param which is by a certain tile index?
        * 
        * @method getTempBlock
        * @param x {number} The x first tile in the row you want to use. (In tiles).
        * @param y {number} The y first tile in the column you want to use. (In tiles).
        * @param width {number} The number of tiles wide.
        * @param height {number} The number of tiles high.
        * @param [collisionOnly=false] {boolean} Get only the tiles that can have collisions.
        * @private
        */ 
        private getTempBlock(x: number, y: number, width: number, height: number, collisionOnly: boolean = false) {

            if (x &lt; 0) x = 0;
            if (y &lt; 0) y = 0;

            if (x + width &gt; this.widthInTiles) width = this.widthInTiles - x + 1;     
            if (y + height &gt; this.heightInTiles) height = this.heightInTiles - y + 1; 

            this._tempTileBlock = [];

            for (var ty = y; ty &lt; y + height; ty++) {
                for (var tx = x; tx &lt; x + width; tx++) {
                    if (this.mapData[ty] &amp;&amp; this.mapData[ty][tx] &amp;&amp; this.mapData[ty][tx].cellIndex !== -1) {
                        if (collisionOnly) {
                            //  We only want to consider the tile for checking if you can actually collide with it
                            if (this.mapData[ty][tx].tileType.allowCollisions != Kiwi.Components.ArcadePhysics.NONE) {
                                this._tempTileBlock.push(this.mapData[ty][tx]);
                            }
                        } else {
                            
                            this._tempTileBlock.push(this.mapData[ty][tx]);
                            
                        }
                    }
                }
            }

        }

        /**
        * Returns all of the tiles that overlap a given entity. 
        * Returns an array with each index containing the tiles
        *
        * @method getTileOverlaps
        * @param object {Entity} The entity that you are checking.
        * @return {Array}
        * @public
        */
        public getTileOverlaps(object: Kiwi.Entity):Array {
            
            //if the object is within the bounds at all.?
            
            var objPos = object.transform;

            if (objPos.worldX &gt; this.transform.worldX + this.widthInPixels || objPos.worldX + object.width &lt; this.transform.worldX || objPos.worldY &gt; this.transform.worldY + this.heightInPixels || objPos.worldY + object.height &lt; this.transform.worldY) {
                return;
            }

            this._tempTileX = Kiwi.Utils.GameMath.snapToFloor(objPos.worldX - this.transform.worldX, this.tileWidth) / this.tileWidth;
            this._tempTileY = Kiwi.Utils.GameMath.snapToFloor(objPos.worldY - this.transform.worldY, this.tileHeight) / this.tileHeight;
            
            this._tempTileW = Kiwi.Utils.GameMath.snapToCeil(object.width, this.tileWidth) / this.tileWidth;
            this._tempTileH = Kiwi.Utils.GameMath.snapToCeil(object.height, this.tileHeight) / this.tileHeight;

            this.getTempBlock(this._tempTileX, this._tempTileY, this._tempTileW + 1, this._tempTileH + 1, true);
            
            return this._tempTileBlock;

        }

        /**
        * Gets a tile&#x27;s index based on the indexs provided.
        * 
        * @method getTileIndex
        * @param x {number}
        * @param y {number}
        * @return {number}
        * @public
        */
        public getTileIndex(x: number, y: number): number {

            if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length) {        //if it is with the bounds
                if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length) {
                    return this.mapData[y][x].tileType.index;              //return
                }
            }

            return null; 
        }

        /**
        * Gets a tile based on the given position it would be in the tile map.
        * 
        * @method getTileIndex
        * @param x {number}
        * @param y {number}
        * @return {Tile}
        * @public
        */
        public getTile(x: number, y: number): Kiwi.GameObjects.Tilemap.Tile {
            if (y &gt;= 0 &amp;&amp; y &lt; this.mapData.length) {        //if it is with the bounds
                if (x &gt;= 0 &amp;&amp; x &lt; this.mapData[y].length) {
                    return this.mapData[y][x];              //return
                }
            }

            return null;
        }

        /**
        * Adds a row of tiles to the tilemap.
        *
        * @method addRow
        * @param row {Array} 
        * @public
        */
        public addRow(row:Array) {

            var data = [];
            
            for (var c = 0; c &lt; row.length; c++) {
                data[c] = new Kiwi.GameObjects.Tilemap.Tile(this.state, this, row[c], this.tileWidth, this.tileHeight, c * this.tileWidth, this.heightInPixels);
                data[c].transform.parent = this.transform;
                data[c].ty = this.heightInTiles;
                data[c].tx = c;
            }

            if (this.widthInTiles == 0) {
                this.widthInTiles = data.length;
                this.widthInPixels = this.widthInTiles * this.tileWidth;
            }

            this.mapData.push(data);

            this.heightInTiles++;
            this.heightInPixels += this.tileHeight;

        }

        /**
        * Renders the tileMap to the stage. It also updates the position component of all of the tiles that appear. [NEED TO UPDATE]
        *
        * @method render
        * @param camera {Camera}
        * @public
        */ 
        public render(camera: Kiwi.Camera) { 
            
            if (this.visiblity === false || this.alpha &lt; 0.1 || this.exists === false) {
                return;
            }
            
            var ctx = this.game.stage.ctx;
            ctx.save();

            if (this.alpha &gt; 0 &amp;&amp; this.alpha &lt;= 1) {
                ctx.globalAlpha = this.alpha;
            }

            var t: Kiwi.Geom.Transform = this.transform;
            var m: Kiwi.Geom.Matrix = t.getConcatenatedMatrix();
            
            ctx.setTransform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX, m.ty + t.rotPointY);

            //  Work out how many tiles we can fit into our camera and round it up for the edges
            this._maxX = Math.min(Math.ceil(camera.width / this.tileWidth) + 1,this.widthInTiles);
            this._maxY = Math.min(Math.ceil(camera.height / this.tileHeight) + 1,this.heightInTiles);
            
            //  And now work out where in the tilemap the camera actually is
            this._startX = Math.floor((camera.transform.x - t.x) / this.tileWidth);
            this._startY = Math.floor((camera.transform.y - t.y) / this.tileHeight);
            
            //boundaries check 
            if (this._startX &lt; 0) {
                this._startX = 0;    
            }    
            if (this._startY &lt; 0) {
                this._startY = 0;
            }

            if (this._maxX &gt; this.widthInTiles) this._maxX = this.widthInTiles;
            if (this._maxY &gt; this.heightInTiles) this._maxY = this.heightInTiles;

            if (this._startX + this._maxX &gt; this.widthInTiles) {
                this._maxX = this.widthInTiles - this._startX;
            }    
            if (this._startY + this._maxY &gt; this.heightInTiles) {
                this._maxY = this.heightInTiles - this._startY;
            }
            
            for (var column = this._startY; column &lt; this._startY + this._maxY; column++) {
                this._columnData = this.mapData[column]; //get the column data
                //careful here.
                for (var tile = this._startX; tile &lt; this._startX + this._maxX; tile++) {
                    
                    if (this._columnData[tile].tileType.cellIndex !== -1) {
                        
                        ctx.drawImage(
                            this._atlas.image,
                            this._columnData[tile].tileType.cellIndex.x,
                            this._columnData[tile].tileType.cellIndex.y,
                            this._columnData[tile].tileType.cellIndex.w,
                            this._columnData[tile].tileType.cellIndex.h,
                            this._columnData[tile].x,
                            this._columnData[tile].y,
                            this.tileWidth,
                            this.tileHeight
                            );
                        
                        this._columnData[tile].physics.update();
                    }


                }
                
            }

            ctx.restore();
            return true;
        
        }
        

    }
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
