<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\components\ArcadePhysics.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Animations.Animation.html">Kiwi.Animations.Animation</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Sequence.html">Kiwi.Animations.Sequence</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tween.html">Kiwi.Animations.Tween</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Back.html">Kiwi.Animations.Tweens.Easing.Back</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Bounce.html">Kiwi.Animations.Tweens.Easing.Bounce</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Circular.html">Kiwi.Animations.Tweens.Easing.Circular</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Cubic.html">Kiwi.Animations.Tweens.Easing.Cubic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Elastic.html">Kiwi.Animations.Tweens.Easing.Elastic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Exponential.html">Kiwi.Animations.Tweens.Easing.Exponential</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Linear.html">Kiwi.Animations.Tweens.Easing.Linear</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quadratic.html">Kiwi.Animations.Tweens.Easing.Quadratic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quartic.html">Kiwi.Animations.Tweens.Easing.Quartic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quintic.html">Kiwi.Animations.Tweens.Easing.Quintic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Sinusoidal.html">Kiwi.Animations.Tweens.Easing.Sinusoidal</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.TweenManager.html">Kiwi.Animations.Tweens.TweenManager</a></li>
            
                <li><a href="../classes/Kiwi.Camera.html">Kiwi.Camera</a></li>
            
                <li><a href="../classes/Kiwi.CameraManager.html">Kiwi.CameraManager</a></li>
            
                <li><a href="../classes/Kiwi.Component.html">Kiwi.Component</a></li>
            
                <li><a href="../classes/Kiwi.ComponentManager.html">Kiwi.ComponentManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.AnimationManager.html">Kiwi.Components.AnimationManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.ArcadePhysics.html">Kiwi.Components.ArcadePhysics</a></li>
            
                <li><a href="../classes/Kiwi.Components.Box.html">Kiwi.Components.Box</a></li>
            
                <li><a href="../classes/Kiwi.Components.Input.html">Kiwi.Components.Input</a></li>
            
                <li><a href="../classes/Kiwi.Components.Sound.html">Kiwi.Components.Sound</a></li>
            
                <li><a href="../classes/Kiwi.Entity.html">Kiwi.Entity</a></li>
            
                <li><a href="../classes/Kiwi.Files.DataLibrary.html">Kiwi.Files.DataLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Files.File.html">Kiwi.Files.File</a></li>
            
                <li><a href="../classes/Kiwi.Files.FileStore.html">Kiwi.Files.FileStore</a></li>
            
                <li><a href="../classes/Kiwi.Files.Loader.html">Kiwi.Files.Loader</a></li>
            
                <li><a href="../classes/Kiwi.Game.html">Kiwi.Game</a></li>
            
                <li><a href="../classes/Kiwi.GameManager.html">Kiwi.GameManager</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Sprite.html">Kiwi.GameObjects.Sprite</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.StaticImage.html">Kiwi.GameObjects.StaticImage</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Textfield.html">Kiwi.GameObjects.Textfield</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.Tile.html">Kiwi.GameObjects.Tilemap.Tile</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMap.html">Kiwi.GameObjects.Tilemap.TileMap</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMapLayer.html">Kiwi.GameObjects.Tilemap.TileMapLayer</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileType.html">Kiwi.GameObjects.Tilemap.TileType</a></li>
            
                <li><a href="../classes/Kiwi.Geom.AABB.html">Kiwi.Geom.AABB</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Circle.html">Kiwi.Geom.Circle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Intersect.html">Kiwi.Geom.Intersect</a></li>
            
                <li><a href="../classes/Kiwi.Geom.IntersectResult.html">Kiwi.Geom.IntersectResult</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Line.html">Kiwi.Geom.Line</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Matrix.html">Kiwi.Geom.Matrix</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Point.html">Kiwi.Geom.Point</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Ray.html">Kiwi.Geom.Ray</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Rectangle.html">Kiwi.Geom.Rectangle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Transform.html">Kiwi.Geom.Transform</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Vector2.html">Kiwi.Geom.Vector2</a></li>
            
                <li><a href="../classes/Kiwi.Group.html">Kiwi.Group</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Counter.html">Kiwi.HUD.HUDComponents.Counter</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Time.html">Kiwi.HUD.HUDComponents.Time</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.WidgetInput.html">Kiwi.HUD.HUDComponents.WidgetInput</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDDisplay.html">Kiwi.HUD.HUDDisplay</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDManager.html">Kiwi.HUD.HUDManager</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDWidget.html">Kiwi.HUD.HUDWidget</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Bar.html">Kiwi.HUD.Widget.Bar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.BasicScore.html">Kiwi.HUD.Widget.BasicScore</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Button.html">Kiwi.HUD.Widget.Button</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Icon.html">Kiwi.HUD.Widget.Icon</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.IconBar.html">Kiwi.HUD.Widget.IconBar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Menu.html">Kiwi.HUD.Widget.Menu</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.MenuItem.html">Kiwi.HUD.Widget.MenuItem</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.TextField.html">Kiwi.HUD.Widget.TextField</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Time.html">Kiwi.HUD.Widget.Time</a></li>
            
                <li><a href="../classes/Kiwi.IChild.html">Kiwi.IChild</a></li>
            
                <li><a href="../classes/Kiwi.Input.Finger.html">Kiwi.Input.Finger</a></li>
            
                <li><a href="../classes/Kiwi.Input.InputManager.html">Kiwi.Input.InputManager</a></li>
            
                <li><a href="../classes/Kiwi.Input.IRenderer.html">Kiwi.Input.IRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Input.Key.html">Kiwi.Input.Key</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keyboard.html">Kiwi.Input.Keyboard</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keycodes.html">Kiwi.Input.Keycodes</a></li>
            
                <li><a href="../classes/Kiwi.Input.Mouse.html">Kiwi.Input.Mouse</a></li>
            
                <li><a href="../classes/Kiwi.Input.MouseCursor.html">Kiwi.Input.MouseCursor</a></li>
            
                <li><a href="../classes/Kiwi.Input.Pointer.html">Kiwi.Input.Pointer</a></li>
            
                <li><a href="../classes/Kiwi.Input.Touch.html">Kiwi.Input.Touch</a></li>
            
                <li><a href="../classes/Kiwi.PluginManager.html">Kiwi.PluginManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.CanvasRenderer.html">Kiwi.Renderers.CanvasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLArrayBuffer.html">Kiwi.Renderers.GLArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLElementArrayBuffer.html">Kiwi.Renderers.GLElementArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLRenderer.html">Kiwi.Renderers.GLRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLShaders.html">Kiwi.Renderers.GLShaders</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLTexture.html">Kiwi.Renderers.GLTexture</a></li>
            
                <li><a href="../classes/Kiwi.Signal.html">Kiwi.Signal</a></li>
            
                <li><a href="../classes/Kiwi.SignalBinding.html">Kiwi.SignalBinding</a></li>
            
                <li><a href="../classes/Kiwi.Sound.Audio.html">Kiwi.Sound.Audio</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioLibrary.html">Kiwi.Sound.AudioLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioManager.html">Kiwi.Sound.AudioManager</a></li>
            
                <li><a href="../classes/Kiwi.Stage.html">Kiwi.Stage</a></li>
            
                <li><a href="../classes/Kiwi.State.html">Kiwi.State</a></li>
            
                <li><a href="../classes/Kiwi.StateConfig.html">Kiwi.StateConfig</a></li>
            
                <li><a href="../classes/Kiwi.StateManager.html">Kiwi.StateManager</a></li>
            
                <li><a href="../classes/Kiwi.System.Bootstrap.html">Kiwi.System.Bootstrap</a></li>
            
                <li><a href="../classes/Kiwi.System.Browser.html">Kiwi.System.Browser</a></li>
            
                <li><a href="../classes/Kiwi.System.Device.html">Kiwi.System.Device</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SingleImage.html">Kiwi.Textures.SingleImage</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SpriteSheet.html">Kiwi.Textures.SpriteSheet</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureAtlas.html">Kiwi.Textures.TextureAtlas</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureLibrary.html">Kiwi.Textures.TextureLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Time.Clock.html">Kiwi.Time.Clock</a></li>
            
                <li><a href="../classes/Kiwi.Time.ClockManager.html">Kiwi.Time.ClockManager</a></li>
            
                <li><a href="../classes/Kiwi.Time.MasterClock.html">Kiwi.Time.MasterClock</a></li>
            
                <li><a href="../classes/Kiwi.Time.Timer.html">Kiwi.Time.Timer</a></li>
            
                <li><a href="../classes/Kiwi.Time.TimerEvent.html">Kiwi.Time.TimerEvent</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Canvas.html">Kiwi.Utils.Canvas</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Common.html">Kiwi.Utils.Common</a></li>
            
                <li><a href="../classes/Kiwi.Utils.GameMath.html">Kiwi.Utils.GameMath</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RandomDataGenerator.html">Kiwi.Utils.RandomDataGenerator</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RequestAnimationFrame.html">Kiwi.Utils.RequestAnimationFrame</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animations.html">Animations</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Easing.html">Easing</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/HUD.html">HUD</a></li>
            
                <li><a href="../modules/HUDComponents.html">HUDComponents</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Renderers.html">Renderers</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
                <li><a href="../modules/Widget.html">Widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\components\ArcadePhysics.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* 
* @module Kiwi
* @submodule Components 
* 
*/ 

module Kiwi.Components {
     
    /**
    * Arcade Physics is an Optional Component that can be used when you are wanting to do basic physics collisions. 
    * These have been ported from Flixel, so most function operate identically to the original flixel functions, though some
    * have been split into multiple functions. Generally where functions originally accepted
    * either groups or gameobjects within the same argument, the ported functions one or the other.
    * http://www.flixel.org/
    * http://www.adamatomic.com/
    *
    * @class ArcadePhysics
    * @constructor
    * @namespace Kiwi.Components
    * @param entity {Entity}
    * @param box {Box}
    * @return {ArcadePhysics}
    * @extends Component
    *
    * @author Adam &#x27;Atomic&#x27; Saltsman, Flixel
    *
    */
    export class ArcadePhysics extends Kiwi.Component {

        constructor(entity:Kiwi.Entity, box: Kiwi.Components.Box) {
            super(entity,&#x27;ArcadePhysics&#x27;);
            
            this._parent = entity;
            this.box = box;
            this.transform = this._parent.transform;

            this.last = new Kiwi.Geom.Point(this.transform.worldX, this.transform.worldY);
            this.mass = 1.0;
            this.elasticity = 0.0;

            this.immovable = false;
            this.moves = true;

            this.touching = ArcadePhysics.NONE;
            this.wasTouching = ArcadePhysics.NONE;
            this.allowCollisions = ArcadePhysics.ANY;

            this.velocity = new Kiwi.Geom.Point();
            this.acceleration = new Kiwi.Geom.Point();
            this.drag = new Kiwi.Geom.Point();
            this.maxVelocity = new Kiwi.Geom.Point(10000, 10000);

            this.angle = 0;
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.angularDrag = 0;
            this.maxAngular = 10000;
        }
        
        /**
        * The Entity that this physics component belongs to.
        * @property _parent
        * @type Kiwi.Entity
        */
        private _parent: Entity;

        /**
        * The transform component.
        * @property transform
        * @type Kiwi.Geom.Transform
        */
        public transform: Kiwi.Geom.Transform;

        /**
        * The bounding box component that the collisions are going to be based off.
        * @property box
        * @type Box
        * @public
        */
        public box: Kiwi.Components.Box;

        /**
        * The type of object that this is.
        * @method objType
        * @return {string}
        * @public
        */
        public objType() {
            return &quot;ArcadePhysics&quot;;
        }

        /**
        * How often the motion should be updated.
        * @property updateInterval
        * @static
        * @default 1 / 10
        * @type number
        */
        public static updateInterval: number = 1 / 10;

        /**
        * Generic value for &quot;left&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property LEFT
        * @type number
        */
        public static LEFT: number = 0x0001;

        /**
        * Generic value for &quot;right&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property RIGHT
        * @type number
        */
        public static RIGHT: number = 0x0010;

        /**
        * Generic value for &quot;up&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property UP
        * @type number
        */
        public static UP: number = 0x0100;

        /**
		* Generic value for &quot;down&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
		* @property DOWN
        * @type number
        */
        public static DOWN: number = 0x1000;

        /**
        * Special-case constant meaning no collisions, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property NONE
        * @type number
        */
        public static NONE: number = 0;

        /**
        * Special-case constant meaning up, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property CEILING
        * @type number
        */
        public static CEILING: number = ArcadePhysics.UP;

        /**
        * Special-case constant meaning down, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property FLOOR
        * @type number
        */
        public static FLOOR: number = ArcadePhysics.DOWN;

        /**
        * Special-case constant meaning only the left and right sides, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property WALL
        * @type number
        */
        public static WALL: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT;

        /**
		* Special-case constant meaning any direction, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
		* @property ANY
        * @type number
        */
        public static ANY: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT | ArcadePhysics.UP | ArcadePhysics.DOWN;

        /**
		* Handy constant used during collision resolution (see &lt;code&gt;separateX()&lt;/code&gt; and &lt;code&gt;separateY()&lt;/code&gt;).
		* @property OVERLAP_BIAS
        * @type number
        */
        public static OVERLAP_BIAS: number = 4;

        /**
		* Whether an object will move/alter position after a collision.
        * @property immovable
        * @type boolean
		*/
        public immovable: boolean;

        /**
        * The basic speed of this object.
        * @property velocity
        * @type Kiwi.Geom.Point
        */
        public velocity: Kiwi.Geom.Point;

        /**
		* The virtual mass of the object. Default value is 1.
		* Currently only used with &lt;code&gt;elasticity&lt;/code&gt; during collision resolution.
		* Change at your own risk; effects seem crazy unpredictable so far!
        * @property mass
        * @type number
		*/
        public mass: number;
        
        /**
        * The bounciness of this object.  Only affects collisions.  Default value is 0, or &quot;not bouncy at all.&quot;
        * @property elasticity
        * @type number
        */
        public elasticity: number;

        /**
        * How fast the speed of this object is changing.
        * Useful for smooth movement and gravity.
        * @property acceleration
        * @type Kiwi.Geom.Point
        */
        public acceleration: Kiwi.Geom.Point;

        /**
        * This isn&#x27;t drag exactly, more like deceleration that is only applied
        * when acceleration is not affecting the sprite.
        * @property drag
        * @type Kiwi.Geom.Point
        */
        public drag: Kiwi.Geom.Point;

        /**
        * If you are using &lt;code&gt;acceleration&lt;/code&gt;, you can use &lt;code&gt;maxVelocity&lt;/code&gt; with it
        * to cap the speed automatically (very useful!).
        * @property maxVelocity
        * @type Kiwi.Geom.Point
        */
        public maxVelocity: Kiwi.Geom.Point;

        /**
        * Set the angle of a sprite to rotate it.
        * WARNING: rotating sprites decreases rendering
        * performance for this sprite by a factor of 10x!
        * @property angle
        * @type number
        */
        public angle: number;

        /**
		* This is how fast you want this sprite to spin.
		* @property angularVelocity
        * @type number
        */
        public angularVelocity: number;
        
        /**
		* How fast the spin speed should change.
        * @property angularAcceleration
        * @type number
        * @public
		*/
        public angularAcceleration: number;
        
        /**
		* Like &lt;code&gt;drag&lt;/code&gt; but for spinning.
        * @property angularDrag
        * @type number
        * @public
		*/
        public angularDrag: number;
        
        /**
        * Use in conjunction with &lt;code&gt;angularAcceleration&lt;/code&gt; for fluid spin speed control.
        * @property maxAngular
        * @type number
        * @public
        */
        public maxAngular: number;

        /**
        * If the Entity that this component is a part of &#x27;moves&#x27; or not, and thus if the physics should update the motion should update each frame.
        * @property moves
        * @type boolean
        * @default true
        * @public
        */
        public moves: boolean;

        /**
        * If the object should seperate when it &#x27;collides&#x27; with another object.
        * @property seperate
        * @type boolean
        * @default false
        * @public
        */
        public seperate: boolean;

        /**
        * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
        * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
        * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
        * @property touching
        * @type number
        * @public
        */
        public touching: number;

        /**
        * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
        * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
        * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
        * @property wasTouching
        * @type number
        * @public
        */
        public wasTouching: number;

        /**
		* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
		* Use bitwise operators to check the values stored here.
		* Useful for things like one-way platforms (e.g. allowCollisions = UP;)
		* The accessor &quot;solid&quot; just flips this variable between NONE and ANY.
		* @property allowCollisions
        * @type number
        * @public
        */
        public allowCollisions: number;

        /**
		* Important variable for collision processing.
		* By default this value is set automatically during &lt;code&gt;preUpdate()&lt;/code&gt;.
		* @property last
        * @type Kiwi.Geom.Point
        * @public
        */
        public last: Kiwi.Geom.Point;

        /**
        * A boolean to indicate if this object is solid or not.
        * @property _solid
        * @type boolean
        * @private
        */
        private _solid: boolean;

        /**
        * A function that is to execute when this object overlaps with another.
        * @property _callbackFunction
        * @type Function
        * @default null
        * @private
        */
        private _callbackFunction: any = null;

        /**
        * The context that the callback method should have when it executes.
        * @property _callbackContext
        * @type Any
        * @private
        */
        private _callbackContext: any = null;

        /**
		* Whether the object collides or not.  For more control over what directions
		* the object will collide from, use collision constants (like LEFT, FLOOR, etc)
		* to set the value of allowCollisions directly.
        * @method solid
        * @param [value] {boolean} If left empty, this will then just toggle between ANY and NONE.
        * @return boolean
		*/
        public solid(value?: boolean): boolean {
            if (value !== undefined) {
                if (value)
                    this.allowCollisions = ArcadePhysics.ANY;
                else
                    this.allowCollisions = ArcadePhysics.NONE;
            }

                return (this.allowCollisions &amp; ArcadePhysics.ANY) &gt; ArcadePhysics.NONE;
        }

        ////////Static functions/////////

        /**
        * A Static method to check to see if two objects collide or not. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collide
        * @static
        * @param gameObject1 {Kiwi.GameObjects.Entity} The first game object.
        * @param gameObject2 {Kiwi.GameObjects.Entity} The second game object.
        * @param [seperate=true] {boolean} If the two gameobjects should seperated when they collide.
        * @return {boolean}
        */
        public static collide(gameObject1: Entity, gameObject2: Entity, seperate: boolean = true): boolean {

            return ArcadePhysics.overlaps(gameObject1, gameObject2, seperate);
        }

        /**
        * A Static method to check to see if a single entity collides with a group of entities. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collideGroup
        * @static
        * @param gameObject {Kiwi.GameObjects.Entity} 
        * @param group {Any} This could be either an Array of GameObjects or a Group containing members. 
        * @param [seperate=true] {boolean} 
        * @return {boolean}
        * @public
        */
        public static collideGroup(gameObject: Entity, group: Kiwi.Group, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsObjectGroup(gameObject, group, seperate);
        }

        /**
        * A Static method to check to see if a group of entities overlap with another group of entities. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collideGroupGroup
        * @static
        * @param group1 {Any} This can either be an array or a Group.
        * @param group2 {Any} Also could either be an array or a Group.
        * @param [seperate=true] {boolean}
        * @return {boolean}
        */
        public static collideGroupGroup(group1: Kiwi.Group, group2: Kiwi.Group, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsGroupGroup(group1, group2, seperate);
        }

        /**
        * A Static method to that checks to see if two objects overlap. Returns a boolean indicating whether they did or not.
        *
        * @method overlaps
        * @static
        * @param gameObject1 {Kiwi.GameObjects.Entity} 
        * @param gameObject2 {Kiwi.GameObjects.Entity} 
        * @param [separateObjects=true] {boolean} 
        * @return {boolean}
        */
        public static overlaps(gameObject1: Entity, gameObject2: Entity, separateObjects: boolean = true): boolean {

            //Flixel uses quadtree here

            //object vs object
            var obj1Physics: ArcadePhysics = gameObject1.components.getComponent(&quot;ArcadePhysics&quot;);

            return obj1Physics.overlaps(gameObject2, separateObjects);

        }

        /**
        * A Static method to that checks to see if a single object overlaps with a group of entities. Returns a boolean indicating whether they did or not.
        *
        * @method overlapsObjectGroup
        * @static
        * @param gameObject {Entity}
        * @param group {Group} 
        * @param [seperateObjects=true] {boolean} If they overlap should the seperate or not
        * @return {boolean}
        * @public
        */
        public static overlapsObjectGroup(gameObject: Entity, group: Kiwi.Group, separateObjects: boolean = true): boolean {

            var objPhysics: ArcadePhysics = gameObject.components.getComponent(&quot;ArcadePhysics&quot;);
            return objPhysics.overlapsGroup(group, separateObjects);
        }

        /**
        * A Static method that checks to see if any objects in a group overlap with objects in another group.
        *
        * @method overlaps
        * @static
        * @param group1 {Group} The first 
        * @param group2 {Any}
        * @param [seperate=true] {boolean} If they overlap should the seperate or not
        * @return {boolean}
        * @public
        */
        public static overlapsGroupGroup(group1: Kiwi.Group, group2: Kiwi.Group, separateObjects: boolean = true): boolean {

            var result: boolean = false;

            var members: IChild[] = group1.members;
            var i: number = 0;
            
            while (i &lt; group1.members.length) {
                if (members[i].childType() == Kiwi.GROUP) {
                    if (ArcadePhysics.overlapsGroupGroup(&lt;Kiwi.Group&gt;members[i++], group2, separateObjects)) result = true;

                } else {
                    if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;members[i++], group2, separateObjects)) result = true;

                }
            }

            return result;
        }

        /**
        * A Statuc method that checks to see if any objects from an Array collide with a Kiwi Group members.
        * 
        * @method overlapsArrayGroup
        * @param array {Array} An array you want to check collide.
        * @param group {Group} A group of objects you want to check overlaps.
        * @param [seperateObjects=true] {Boolean} If when a collision is found the objects should seperate out.
        * @return {Boolean} 
        */
        public static overlapsArrayGroup(array: Array, group: Kiwi.Group, separateObjects: boolean = true) {

            var result: boolean = false;

            //loop through the array 
            for (var i = 0; i &lt; array.length; i++) {
                if (typeof array[i].childType !== &quot;undefined&quot;) {

                    if (array[i].childType() === Kiwi.ENTITY) {
                        if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;array[i], group, separateObjects))
                            result = true;
                    } else if (array[i].childType() === Kiwi.GROUP) {
                        if (ArcadePhysics.overlapsGroupGroup(&lt;Kiwi.Group&gt;array[i], group, separateObjects))
                            result = true;
                    }

                }
            }

            return result;
        }

        /**
        * A static method for seperating two objects. Both objects need to have physics, position and size components in order for this to work.
        * 
        * @method seperate
        * @static
        * @param {Kiwi.Entity} object1
        * @param {Kiwi.Entity} object2
        * @return {boolean}
        * @public
        */
        public static separate(object1: Kiwi.Entity, object2: Kiwi.Entity): boolean {
            
            var separatedX: boolean = this.separateX(object1, object2);
            var separatedY: boolean = this.separateY(object1, object2);
            return separatedX || separatedY;
        }

        /**
		* The X-axis component of the object separation process.
		* 
        * @method seperateX
        * @static
		* @param {Kiwi.Entity} object1
		* @param {Kiwi.Entity} object2
		* @return {boolean} Whether the objects in fact touched and were separated along the X axis.
		*/
        public static separateX(object1, object2): boolean {

            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components._components[&quot;ArcadePhysics&quot;];
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components._components[&quot;ArcadePhysics&quot;];

            //can&#x27;t separate two immovable objects
            var obj1immovable: boolean = phys1.immovable;
            var obj2immovable: boolean = phys2.immovable;
            if (obj1immovable &amp;&amp; obj2immovable)
                return false;

            //First, get the two object deltas
            var overlap: number = 0;
            var obj1delta: number = phys1.box.worldHitbox.x - phys1.last.x;
            var obj2delta: number = phys2.box.worldHitbox.x - phys2.last.x;
            
            if (obj1delta != obj2delta) { //perhaps remove this section.

                //Check if the X hulls actually overlap
                var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
                
                //where they were before
                var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys1.box.worldHitbox.x - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.last.y, phys1.box.worldHitbox.width + ((obj1delta &gt; 0) ? obj1delta : -obj1delta), phys1.box.worldHitbox.height);
                var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys2.box.worldHitbox.x - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.last.y, phys2.box.worldHitbox.width + ((obj2delta &gt; 0) ? obj2delta : -obj2delta), phys2.box.worldHitbox.height);
                if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {
                    var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                    //If they did overlap (and can), figure out by how much and flip the corresponding flags
                    if (obj1delta &gt; obj2delta) {
                        overlap = phys1.box.worldHitbox.x + phys1.box.worldHitbox.width - phys2.box.worldHitbox.x;
                        if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.RIGHT) || !(phys2.allowCollisions &amp; ArcadePhysics.LEFT)) {
                            overlap = 0;
                    } else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                            phys2.touching |= ArcadePhysics.LEFT;
                        }
                    }
                    else if (obj1delta &lt; obj2delta) {
                        overlap = phys1.box.worldHitbox.x - phys2.box.worldHitbox.width - phys2.box.worldHitbox.x;
                        if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.LEFT) || !(phys2.allowCollisions &amp; ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.LEFT;
                            phys2.touching |= ArcadePhysics.RIGHT;
                        }
                    }
                }
            }

            //Then adjust their positions and velocities accordingly (if there was any overlap)
            if (overlap != 0) {
                var obj1v: number = phys1.velocity.x;
                var obj2v: number = phys2.velocity.x;
                
                if (!obj1immovable &amp;&amp; !obj2immovable) { //no beans...
                    overlap *= 0.5;
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys2.transform.x = phys2.transform.x + overlap;

                    var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                    var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                    var average: number = (obj1velocity + obj2velocity) * 0.5;
                    obj1velocity -= average;
                    obj2velocity -= average;
                    phys1.velocity.x = average + obj1velocity * phys1.elasticity;
                    phys2.velocity.x = average + obj2velocity * phys2.elasticity;

                }
                else if (!obj1immovable) {
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys1.velocity.x = obj2v - obj1v * phys1.elasticity;
                }
                else if (!obj2immovable) {

                    phys2.transform.x = phys2.transform.x + overlap;
                    phys2.velocity.x = obj1v - obj2v * phys2.elasticity;
                }
                return true;
            }
            else
                return false;
        }

        /**
		* The Y-axis component of the object separation process.
		*
        * @method seperateY 
		* @static
        * @param {Kiwi.Entity} object1
		* @param {Kiwi.Entity} object2
		* @return {boolean} Whether the objects in fact touched and were separated along the Y axis.
        */
        public static separateY(object1, object2): boolean {

            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components._components[&quot;ArcadePhysics&quot;];
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components._components[&quot;ArcadePhysics&quot;];

            //can&#x27;t separate two immovable objects
            var obj1immovable: boolean = phys1.immovable;
            var obj2immovable: boolean = phys2.immovable;
            if (obj1immovable &amp;&amp; obj2immovable)
                return false;

            //removed tilemaps

            //First, get the two object deltas
            var overlap: number = 0;

            var obj1delta: number = phys1.box.worldHitbox.y - phys1.last.y;

            var obj2delta: number = phys2.box.worldHitbox.y - phys2.last.y;
            if (obj1delta != obj2delta) {
                //Check if the Y hulls actually overlap
                var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;

                var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys1.box.worldHitbox.x, phys1.box.worldHitbox.y - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.box.worldHitbox.width, phys1.box.worldHitbox.height + obj1deltaAbs);
                var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys2.box.worldHitbox.x, phys2.box.worldHitbox.y - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.box.worldHitbox.width, phys2.box.worldHitbox.height + obj2deltaAbs);
                if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {
                    var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                    //If they did overlap (and can), figure out by how much and flip the corresponding flags
                    if (obj1delta &gt; obj2delta) {
                        overlap = phys1.box.worldHitbox.y + phys1.box.worldHitbox.height - phys2.box.worldHitbox.y;
                        if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.DOWN) || !(phys2.allowCollisions &amp; ArcadePhysics.UP)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.DOWN;
                            phys2.touching |= ArcadePhysics.UP;
                        }
                    }
                    else if (obj1delta &lt; obj2delta) {
                        overlap = phys1.box.worldHitbox.y - phys2.box.worldHitbox.height - phys2.box.worldHitbox.y;
                        if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.UP) || !(phys2.allowCollisions &amp; ArcadePhysics.DOWN)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.UP;
                            phys2.touching |= ArcadePhysics.DOWN;
                        }
                    }
                }
            }

            //Then adjust their positions and velocities accordingly (if there was any overlap)
            if (overlap != 0) {
                var obj1v: number = phys1.velocity.y;
                var obj2v: number = phys2.velocity.y;

                if (!obj1immovable &amp;&amp; !obj2immovable) {
                    overlap *= 0.5;
                    phys1.transform.y = phys1.transform.y - overlap;
                    phys2.transform.y = phys2.transform.y + overlap;

                    var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                    var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                    var average: number = (obj1velocity + obj2velocity) * 0.5;
                    obj1velocity -= average;
                    obj2velocity -= average;
                    phys1.velocity.y = average + obj1velocity * phys1.elasticity;
                    phys2.velocity.y = average + obj2velocity * phys2.elasticity;
                }
                else if (!obj1immovable) {
                    phys1.transform.y = phys1.transform.y - overlap;
                    phys1.velocity.y = obj2v - obj1v * phys1.elasticity;
                    //This is special case code that handles cases like horizontal moving platforms you can ride
                    if (object2.active &amp;&amp; phys2.moves &amp;&amp; (obj1delta &gt; obj2delta))
                        phys1.transform.x = phys1.transform.worldX + object2.transform.worldX - phys2.last.x; 
                }
                else if (!obj2immovable) {
                    phys2.transform.y = phys2.transform.y + overlap;
                    phys2.velocity.y = obj1v - obj2v * phys2.elasticity;
                    //This is special case code that handles cases like horizontal moving platforms you can ride
                    if (object1.active &amp;&amp; phys1.moves &amp;&amp; (obj1delta &lt; obj2delta))
                        phys2.transform.x = phys2.transform.worldX + object1.transform.worldX - phys1.last.x; 
                }
                return true;
            }
            else
                return false;

        }

        /**
        * Computes the velocity based on the parameters passed.  
        * @method computeVelocity
        * @static
        * @param velocity {number}
        * @param [acceleration=0] {number}
        * @param [drag=0] {number}
        * @param [max=10000] {number}
        * @return {Number} The new velocity
        */
        public static computeVelocity(velocity: number, acceleration: number = 0, drag: number = 0, max: number = 10000):number {
            
            if (acceleration != 0)
                velocity += acceleration * ArcadePhysics.updateInterval;
            else if (drag != 0) {
                drag = drag * ArcadePhysics.updateInterval;
                if (velocity - drag &gt; 0)
                    velocity = velocity - drag;
                else if (velocity + drag &lt; 0)
                    velocity += drag;
                else
                    velocity = 0;
            }
            if ((velocity != 0) &amp;&amp; (max != 10000)) {
                if (velocity &gt; max)
                    velocity = max;
                else if (velocity &lt; -max)
                    velocity = -max;
            }
            return velocity;
        }


        ////////Instance Functions/////////

        /**
        * A method to check to see if the parent of this physics component overlaps with another Kiwi.Entity. If seperateObjects is true it will seperate the two entities based on their bounding box.
        * 
        * @method overlaps
        * @param gameObject {Kiwi.Entity}
        * @param [seperateObjects=false] {boolean}
        * @return {boolean}
        */
        public overlaps(gameObject: Entity, separateObjects: boolean = false): boolean {
            
            if (gameObject.components.hasComponent(&#x27;Box&#x27;) == false) return;

            var objTransform: Kiwi.Geom.Transform = gameObject.transform;
            var box: Kiwi.Components.Box = gameObject.components.getComponent(&#x27;Box&#x27;);

            var result: boolean = (box.worldHitbox.x + box.worldHitbox.width &gt; this.box.worldHitbox.x) &amp;&amp; (box.worldHitbox.x &lt; this.box.worldHitbox.x + this.box.worldHitbox.width) &amp;&amp;
                (box.worldHitbox.y + box.worldHitbox.height &gt; this.box.worldHitbox.y) &amp;&amp; (box.worldHitbox.y &lt; this.box.worldHitbox.y + this.box.worldHitbox.height);

            if (result &amp;&amp; separateObjects) {
                ArcadePhysics.separate(this._parent, gameObject);
            }

            if (result &amp;&amp; this._callbackFunction !== null &amp;&amp; this._callbackContext !== null) {
                this._callbackFunction.call(this._callbackContext, this._parent, gameObject);
            }

            return result;

        }

        /**
        * A method to check to see if the parent of this physics component overlaps with another individual in a Kiwi Group.
        * 
        * @method overlapsGroup
        * @param group {Kiwi.Group}
        * @param [seperateObjects=false] {boolean} 
        * @return { boolean }
        */
        public overlapsGroup(group: Kiwi.Group, separateObjects: boolean = false): boolean {

            var results: boolean = false;

            for (var i = 0; i &lt; group.members.length; i++) {

                if (group.members[i].childType() === Kiwi.GROUP) {
                    //recursively check overlap
                    this.overlapsGroup(&lt;Kiwi.Group&gt;group.members[i], separateObjects);

                } else {
                    //otherwise its an entity

                    if (this.overlaps(&lt;Kiwi.Entity&gt;group.members[i], separateObjects)) {
                        if (this._callbackContext !== null &amp;&amp; this._callbackFunction !== null)
                            this._callbackFunction.call(this._callbackContext, this._parent, group.members[i]);
                        results = true;
                    }

                }
            }

            return results;
        }

        /**
        * A method to check to see if the parent of this physics component overlaps with a Entity that is held in an array.
        * @method overlapsArray
        * @param array {Array} The array of GameObjects you want to check.
        * @param [separateObjects=false] {boolean} If when the objects collide you want them to seperate outwards.
        * @return {boolean} If a collision was detected or not.
        */ 
        public overlapsArray(array: Array, separateObjects: boolean = false): boolean {
            
            var results: boolean = false;

            for (var i = 0; i &lt; array.length; i++) {

                if (typeof array[i].childType !== &quot;undefined&quot; &amp;&amp; array[i].childType() === Kiwi.ENTITY) {
                    if (this.overlaps(&lt;Kiwi.Entity&gt;array[i], separateObjects)) {
                        this._callbackFunction.call(this._callbackContext, this._parent, array[i]);
                        results = true;
                    }
                }

            }
            
            return results;
        }

        /**
        * Updates the position of this object. Automatically called if the &#x27;moves&#x27; parameter is true.  
        * @method updateMotion
        * @public
        */
        public updateMotion() {
            
            var delta: number;
            var velocityDelta: number;
            
            //Update the motion calculated from rotation.
            velocityDelta = (ArcadePhysics.computeVelocity(this.angularVelocity, this.angularAcceleration, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
            this.angularVelocity += velocityDelta;
            this.angle += this.angularVelocity * ArcadePhysics.updateInterval;
            this.angularVelocity += velocityDelta;
           
            //Update the motion on the x-axis.
            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.x, this.acceleration.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
            this.velocity.x += velocityDelta;
            delta = this.velocity.x * ArcadePhysics.updateInterval;
            this.velocity.x += velocityDelta;
            this.transform.x = this.transform.x + delta;

            //Update the motion on the y-axis.
            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.y, this.acceleration.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
            this.velocity.y += velocityDelta;
            delta = this.velocity.y * ArcadePhysics.updateInterval;
            this.velocity.y += velocityDelta;
            this.transform.y = this.transform.y + delta;
        
        }
    
        /**
        * Sets up a callback function that will run when this object overlaps with another.
        * 
        * @method setCallback
        * @param callbackFunction {function}
        * @param callbackContext {any} 
        */
        public setCallback(callbackFunction, callbackContext) {
            this._callbackFunction = callbackFunction;
            this._callbackContext = callbackContext;
        }

        /**
        * Returns the parent of this entity. Mainly used for executing callbacks.
        * @method parent
        * @return {Kiwi.Entity}
        * @public
        */
        public parent() {
            return this._parent;
        }

        /**
        * The Update loop of the physics component
        * @method update
        * @public
        */
        public update() {

            //Flixel preupdate
            this.last.x = this.box.worldHitbox.x;
            this.last.y = this.box.worldHitbox.y;

            //Flixel postupdate
            if (this.moves)
                this.updateMotion();

            this.wasTouching = this.touching;
            this.touching = ArcadePhysics.NONE;


        }

        /**
        * Removes all properties that refer to other objects or outside of this class in order to flag this object for garbage collection.
        * @method destroy
        * @public
        */
        public destroy() {
            super.destroy();

            delete this.transform;
            delete this._parent;
            delete this._callbackContext;
            delete this._callbackFunction;
        }
        

    }

}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
