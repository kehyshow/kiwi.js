<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\components\ArcadePhysics.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.9</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AABB.html">AABB</a></li>
            
                <li><a href="../classes/Anim.html">Anim</a></li>
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/ArcadePhysics.html">ArcadePhysics</a></li>
            
                <li><a href="../classes/Audio.html">Audio</a></li>
            
                <li><a href="../classes/AudioManager.html">AudioManager</a></li>
            
                <li><a href="../classes/Bootstrap.html">Bootstrap</a></li>
            
                <li><a href="../classes/Box.html">Box</a></li>
            
                <li><a href="../classes/Browser.html">Browser</a></li>
            
                <li><a href="../classes/Camera.html">Camera</a></li>
            
                <li><a href="../classes/CameraManager.html">CameraManager</a></li>
            
                <li><a href="../classes/Canvas.html">Canvas</a></li>
            
                <li><a href="../classes/Circle.html">Circle</a></li>
            
                <li><a href="../classes/Clock.html">Clock</a></li>
            
                <li><a href="../classes/Common.html">Common</a></li>
            
                <li><a href="../classes/Component.html">Component</a></li>
            
                <li><a href="../classes/ComponentManager.html">ComponentManager</a></li>
            
                <li><a href="../classes/DataLibrary.html">DataLibrary</a></li>
            
                <li><a href="../classes/Device.html">Device</a></li>
            
                <li><a href="../classes/Entity.html">Entity</a></li>
            
                <li><a href="../classes/File.html">File</a></li>
            
                <li><a href="../classes/FileStore.html">FileStore</a></li>
            
                <li><a href="../classes/Finger.html">Finger</a></li>
            
                <li><a href="../classes/Game.html">Game</a></li>
            
                <li><a href="../classes/GameManager.html">GameManager</a></li>
            
                <li><a href="../classes/GameMath.html">GameMath</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/IChild.html">IChild</a></li>
            
                <li><a href="../classes/Input.html">Input</a></li>
            
                <li><a href="../classes/Intersect.html">Intersect</a></li>
            
                <li><a href="../classes/IntersectResult.html">IntersectResult</a></li>
            
                <li><a href="../classes/Key.html">Key</a></li>
            
                <li><a href="../classes/Keyboard.html">Keyboard</a></li>
            
                <li><a href="../classes/Keycodes.html">Keycodes</a></li>
            
                <li><a href="../classes/Line.html">Line</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Manager.html">Manager</a></li>
            
                <li><a href="../classes/MasterClock.html">MasterClock</a></li>
            
                <li><a href="../classes/Matrix.html">Matrix</a></li>
            
                <li><a href="../classes/Mouse.html">Mouse</a></li>
            
                <li><a href="../classes/MouseCursor.html">MouseCursor</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Pointer.html">Pointer</a></li>
            
                <li><a href="../classes/RandomDataGenerator.html">RandomDataGenerator</a></li>
            
                <li><a href="../classes/Ray.html">Ray</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/RequestAnimationFrame.html">RequestAnimationFrame</a></li>
            
                <li><a href="../classes/Sequence.html">Sequence</a></li>
            
                <li><a href="../classes/Signal.html">Signal</a></li>
            
                <li><a href="../classes/SignalBinding.html">SignalBinding</a></li>
            
                <li><a href="../classes/SingleImage.html">SingleImage</a></li>
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a href="../classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="../classes/Stage.html">Stage</a></li>
            
                <li><a href="../classes/State.html">State</a></li>
            
                <li><a href="../classes/StateConfig.html">StateConfig</a></li>
            
                <li><a href="../classes/StateManager.html">StateManager</a></li>
            
                <li><a href="../classes/StaticImage.html">StaticImage</a></li>
            
                <li><a href="../classes/Textfield.html">Textfield</a></li>
            
                <li><a href="../classes/TextureAtlas.html">TextureAtlas</a></li>
            
                <li><a href="../classes/TextureLibrary.html">TextureLibrary</a></li>
            
                <li><a href="../classes/Timer.html">Timer</a></li>
            
                <li><a href="../classes/Touch.html">Touch</a></li>
            
                <li><a href="../classes/Transform.html">Transform</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/Vector2.html">Vector2</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animation.html">Animation</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\components\ArcadePhysics.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Kiwi - Components
* @module Kiwi
* @submodule Components 
* 
*/ 

module Kiwi.Components {
     
    /**
    * Ported from Flixel, most functions operation identically to the original flixel functions, though some
    * have been split into multiple functions. Generally where functions originally accepted
    * either groups or gameobjects within the same argument, the ported functions one or the other.
    * http://www.flixel.org/
    * http://www.adamatomic.com/
    *
    * @class ArcadePhysics
    *
    * @author Adam &#x27;Atomic&#x27; Saltsman, Flixel
    *
    */
    export class ArcadePhysics extends Kiwi.Component {

        /**
        * The Entity that this physics component belongs to.
        * @property _parent
        * @type Kiwi.Entity
        */
        private _parent: Entity;
        
        /**
        * The transform component.
        * @property transform
        * @type Kiwi.Geom.Transform
        */
        public transform: Kiwi.Geom.Transform;
        
        /**
        * The width component that this physics component uses.
        * @property width
        * @type number
        */
        public width: number;   //convert to hitbox 

        /**
        * The height that this physics component uses.
        * @property height
        * @type number
        */ 
        public height: number;

        /**
        *
        * @constructor
        * @param {Kiwi.Entity} entity 
        * @return {Kiwi.Components.ArcadePhysics}
        */
        constructor(entity:Kiwi.Entity) {
            super(entity,&#x27;ArcadePhysics&#x27;);
            
            this._parent = entity;
            this.transform = this._parent.transform;
            this.width = this._parent.width;
            this.height = this._parent.height;

            this.last = new Kiwi.Geom.Point(this.transform.x, this.transform.y);
            this.mass = 1.0;
            this.elasticity = 0.0;

            this.immovable = false;
            this.moves = true;

            this.touching = ArcadePhysics.NONE;
            this.wasTouching = ArcadePhysics.NONE;
            this.allowCollisions = ArcadePhysics.ANY;

            this.velocity = new Kiwi.Geom.Point();
            this.acceleration = new Kiwi.Geom.Point();
            this.drag = new Kiwi.Geom.Point();
            this.maxVelocity = new Kiwi.Geom.Point(10000, 10000);

            this.angle = 0;
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.angularDrag = 0;
            this.maxAngular = 10000;
        }

        /**
        * The type of object that this is.
        * 
        * @method objType
        * @return {string}
        */
        public objType() {
            return &quot;ArcadePhysics&quot;;
        }

        /**
         * Generic value for &quot;left&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
         * @property LEFT
         * @type number
         */
        public static LEFT: number = 0x0001;

        /**
         * Generic value for &quot;right&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
         * @property RIGHT
         * @type number
         */
        public static RIGHT: number = 0x0010;

        /**
         * Generic value for &quot;up&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
         * @property UP
         * @type number
         */
        public static UP: number = 0x0100;

        /**
		 * Generic value for &quot;down&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
		 * @property DOWN
         * @type number
         */
        public static DOWN: number = 0x1000;

        /**
         * Special-case constant meaning no collisions, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
         * @property NONE
         * @type number
         */
        public static NONE: number = 0;

        /**
         * Special-case constant meaning up, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
         * @property CEILING
         * @type number
         */
        public static CEILING: number = ArcadePhysics.UP;

        /**
         * Special-case constant meaning down, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
         * @property FLOOR
         * @type number
         */
        public static FLOOR: number = ArcadePhysics.DOWN;

        /**
         * Special-case constant meaning only the left and right sides, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
         * @property WALL
         * @type number
         */
        public static WALL: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT;

        /**
		 * Special-case constant meaning any direction, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
		 * @property ANY
         * @type number
         */
        public static ANY: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT | ArcadePhysics.UP | ArcadePhysics.DOWN;

        /**
		 * Handy constant used during collision resolution (see &lt;code&gt;separateX()&lt;/code&gt; and &lt;code&gt;separateY()&lt;/code&gt;).
		 * @property OVERLAP_BIAS
         * @type number
         */
        public static OVERLAP_BIAS: number = 4;

        /**
		 * Whether an object will move/alter position after a collision.
         * @property immovable
         * @type boolean
		 */
        public immovable: boolean;

        /**
         * The basic speed of this object.
         * @property velocity
         * @type Kiwi.Geom.Point
         */
        public velocity: Kiwi.Geom.Point;

        /**
		 * The virtual mass of the object. Default value is 1.
		 * Currently only used with &lt;code&gt;elasticity&lt;/code&gt; during collision resolution.
		 * Change at your own risk; effects seem crazy unpredictable so far!
         * @property mass
         * @type number
		 */
        public mass: number;
        
        /**
         * The bounciness of this object.  Only affects collisions.  Default value is 0, or &quot;not bouncy at all.&quot;
         * @property elasticity
         * @type number
         */
        public elasticity: number;

        /**
         * How fast the speed of this object is changing.
         * Useful for smooth movement and gravity.
         * @property acceleration
         * @type Kiwi.Geom.Point
         */
        public acceleration: Kiwi.Geom.Point;

        /**
         * This isn&#x27;t drag exactly, more like deceleration that is only applied
         * when acceleration is not affecting the sprite.
         * @property drag
         * @type Kiwi.Geom.Point
         */
        public drag: Kiwi.Geom.Point;

        /**
         * If you are using &lt;code&gt;acceleration&lt;/code&gt;, you can use &lt;code&gt;maxVelocity&lt;/code&gt; with it
         * to cap the speed automatically (very useful!).
         * @property maxVelocity
         * @type Kiwi.Geom.Point
         */
        public maxVelocity: Kiwi.Geom.Point;

        /**
         * Set the angle of a sprite to rotate it.
         * WARNING: rotating sprites decreases rendering
         * performance for this sprite by a factor of 10x!
         * @property angle
         * @type number
         */
        public angle: number;

        /**
		 * This is how fast you want this sprite to spin.
		 * @property angularVelocity
         * @type number
         */
        public angularVelocity: number;
        
        /**
		 * How fast the spin speed should change.
         * @property angularAcceleration
         * @type number
		 */
        public angularAcceleration: number;
        
        /**
		 * Like &lt;code&gt;drag&lt;/code&gt; but for spinning.
         * @property angularDrag
         * @type number
		 */
        public angularDrag: number;
        
        /**
         * Use in conjunction with &lt;code&gt;angularAcceleration&lt;/code&gt; for fluid spin speed control.
         * @property maxAngular
         * @type number
         */
        public maxAngular: number;

        public moves: boolean;

        /**
         * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
         * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
         * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
         */
        public touching: number;

        /**
         * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
         * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
         * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
         */
        public wasTouching: number;

        /**
		 * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
		 * Use bitwise operators to check the values stored here.
		 * Useful for things like one-way platforms (e.g. allowCollisions = UP;)
		 * The accessor &quot;solid&quot; just flips this variable between NONE and ANY.
		 */
        public allowCollisions: number;

        /**
		 * Important variable for collision processing.
		 * By default this value is set automatically during &lt;code&gt;preUpdate()&lt;/code&gt;.
		 */
        public last: Kiwi.Geom.Point;

        /**
        * A boolean to indicate if this object is solid or not.
        * @private
        */
        private _solid: boolean;

        /**
        * A function that is to execute when this object overlaps with another.
        * @private
        */
        private _callbackFunction: any = null;

        /**
        * The context that the callback method should have when it executes.
        * @private
        */
        private _callbackContext: any = null;

        /**
		 * Whether the object collides or not.  For more control over what directions
		 * the object will collide from, use collision constants (like LEFT, FLOOR, etc)
		 * to set the value of allowCollisions directly.
         * @method solid
         * @param {boolean} value
         * @return boolean
		 */
        public solid(value?: boolean): boolean {
            if (value !== undefined) {
                if (value)
                    this.allowCollisions = ArcadePhysics.ANY;
                else
                    this.allowCollisions = ArcadePhysics.NONE;
            }

                return (this.allowCollisions &amp; ArcadePhysics.ANY) &gt; ArcadePhysics.NONE;
        }

        ////////Static functions/////////

        /*
        * A Static method to check to see if two objects collide or not. Returns a boolean indicating weither they overlaped or not.
        *
        * @method collide
        * @param {Kiwi.GameObjects.Entity} gameObject1
        * @param {Kiwi.GameObjects.Entity} gameObject2
        * @param {boolean} seperate
        * @return {boolean}
        */
        public static collide(gameObject1: Entity, gameObject2: Entity, seperate: boolean = true): boolean {

            return ArcadePhysics.overlaps(gameObject1, gameObject2, seperate);
        }

        /*
        * A Static method to check to see if a single entity collides with a group of entities. Returns a boolean indicating weither they overlaped or not.
        *
        * @method collideGroup
        * @param {Kiwi.GameObjects.Entity} gameObject1
        * @param {Any} group
        * @param {boolean} seperate
        * @return {boolean}
        */
        public static collideGroup(gameObject: Entity, group: any, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsObjectGroup(gameObject, group, seperate);
        }

        /*
        * A Static method to check to see if a group of entities overlap with another group of entities. Returns a boolean indicating weither they overlaped or not.
        *
        * @method collideGroupGroup
        * @param {Kiwi.GameObjects.Entity} gameObject1
        * @param {Any} group
        * @param {boolean} seperate
        * @return {boolean}
        */
        public static collideGroupGroup(group1: any, group2: any, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsGroupGroup(group1, group2, seperate);
        }

        /*
        * A Static method to that checks to see if two objects overlap. Returns a boolean indicating weither they did or not.
        *
        * @method overlaps
        * @param {Kiwi.GameObjects.Entity} gameObject1
        * @param {Kiwi.GameObjects.Entity} gameObject2
        * @param {boolean} separate
        * @return {boolean}
        */
        public static overlaps(gameObject1: Entity, gameObject2: Entity, separateObjects: boolean = true): boolean {

            //Flixel uses quadtree here

            //object vs object
            var obj1Physics: ArcadePhysics = gameObject1.components.getComponent(&quot;ArcadePhysics&quot;);

            return obj1Physics.overlaps(gameObject2, separateObjects);

        }

        /*
        * A Static method to that checks to see if a single object overlaps with a group of entities. Returns a boolean indicating weither they did or not.
        *
        * @method overlaps
        * @param {Kiwi.GameObjects.Entity} gameObject1
        * @param {Any} group
        * @param {boolean} separate - If they overlap should the seperate or not
        * @return {boolean}
        */
        public static overlapsObjectGroup(gameObject: Entity, group: any, separateObjects: boolean = true): boolean {

            var objPhysics: ArcadePhysics = gameObject.components.getComponent(&quot;ArcadePhysics&quot;);
            return objPhysics.overlapsGroup(group, separateObjects);
        }

        /*
        * A Static method that checks to see if any objects in a group overlap with objects in another group.
        *
        * @method overlaps
        * @param {Any} gameObject1
        * @param {Any} gameObject2
        * @param {boolean} separate - If they overlap should the seperate or not
        * @return {boolean}
        */
        public static overlapsGroupGroup(group1: any, group2: any, separateObjects: boolean = true): boolean {
            
            var result: boolean = false; 

            if (group1.childType !== undefined &amp;&amp; group1.childType() === Kiwi.GROUP) {
                //if group1 is a type of group...

                var members: IChild[] = group1.members;
                var i: number = 0;
                
                while (i &lt; group1.members.length) {
                    if (members[i].childType() == Kiwi.GROUP) {
                        if (ArcadePhysics.overlapsGroupGroup(&lt;Kiwi.Group&gt;members[i++], group2, separateObjects)) result = true;
                    } else {
                        if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;members[i++], group2, separateObjects)) result = true;
                    }
                }
            } else if (Object.prototype.toString.call(group1) == &#x27;[object Array]&#x27;) {
                //loop through the array 
                for (var i = 0; i &lt; group1.length; i++) {
                    if (group1[i].childType !== undefined &amp;&amp; group1[i].childType() === Kiwi.ENTITY) {
                        if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;group1[i], group2, separateObjects)) 
                            result = true;
                    }
                }

            } 

            return result;
        }

        /*
        * A static method for seperating two objects. Both objects need to have physics, position and size components in order for this to work.
        * 
        * @method seperate
        * @param {Kiwi.Entity} object1
        * @param {Kiwi.Entity} object2
        * @return {boolean}
        */
        public static separate(object1: Kiwi.Entity, object2: Kiwi.Entity): boolean {
            
            var separatedX: boolean = this.separateX(object1, object2);
            var separatedY: boolean = this.separateY(object1, object2);
            return separatedX || separatedY;
        }

        /**
		 * The X-axis component of the object separation process.
		 * 
		 * @param	{Kiwi.Entity} object1
		 * @param	{Kiwi.Entity} object2
		 * 
		 * @return	Whether the objects in fact touched and were separated along the X axis.
		 */
        public static separateX(object1, object2): boolean {

            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components._components[&quot;ArcadePhysics&quot;];
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components._components[&quot;ArcadePhysics&quot;];

            //can&#x27;t separate two immovable objects
            var obj1immovable: boolean = phys1.immovable;
            var obj2immovable: boolean = phys2.immovable;
            if (obj1immovable &amp;&amp; obj2immovable)
                return false;

            //First, get the two object deltas
            var overlap: number = 0;
            var obj1delta: number = phys1.transform.x - phys1.last.x;
            var obj2delta: number = phys2.transform.x - phys2.last.x;
            
            if (obj1delta != obj2delta) { //perhaps remove this section.

                //Check if the X hulls actually overlap
                var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
                //where they were before
                var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys1.transform.x - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.last.y, phys1.width + ((obj1delta &gt; 0) ? obj1delta : -obj1delta), phys1.height);
                var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys2.transform.x - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.last.y, phys2.width + ((obj2delta &gt; 0) ? obj2delta : -obj2delta), phys2.height);
                if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {
                    var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                    //If they did overlap (and can), figure out by how much and flip the corresponding flags
                    if (obj1delta &gt; obj2delta) {
                        overlap = phys1.transform.x + phys1.width - phys2.transform.x;
                        if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.RIGHT) || !(phys2.allowCollisions &amp; ArcadePhysics.LEFT)) {
                            overlap = 0;
                    } else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                            phys2.touching |= ArcadePhysics.LEFT;
                        }
                    }
                    else if (obj1delta &lt; obj2delta) {
                        overlap = phys1.transform.x - phys2.width - phys2.transform.x;
                        if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.LEFT) || !(phys2.allowCollisions &amp; ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.LEFT;
                            phys2.touching |= ArcadePhysics.RIGHT;
                        }
                    }
                }
            }

            //Then adjust their positions and velocities accordingly (if there was any overlap)
            if (overlap != 0) {
                var obj1v: number = phys1.velocity.x;
                var obj2v: number = phys2.velocity.x;
                
                if (!obj1immovable &amp;&amp; !obj2immovable) { //no beans...
                    overlap *= 0.5;
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys2.transform.x = phys2.transform.x + overlap;

                    var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                    var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                    var average: number = (obj1velocity + obj2velocity) * 0.5;
                    obj1velocity -= average;
                    obj2velocity -= average;
                    phys1.velocity.x = average + obj1velocity * phys1.elasticity;
                    phys2.velocity.x = average + obj2velocity * phys2.elasticity;

                }
                else if (!obj1immovable) {
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys1.velocity.x = obj2v - obj1v * phys1.elasticity;
                }
                else if (!obj2immovable) {

                    phys2.transform.x = phys2.transform.x + overlap;
                    phys2.velocity.x = obj1v - obj2v * phys2.elasticity;
                }
                return true;
            }
            else
                return false;
        }

        /**
		 * The Y-axis component of the object separation process.
		 * 
		 * @param	{Kiwi.Entity} object1
		 * @param	{Kiwi.Entity} object2
		 * 
		 * @return	Whether the objects in fact touched and were separated along the Y axis.
		 */
        public static separateY(object1, object2): boolean {

            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components._components[&quot;ArcadePhysics&quot;];
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components._components[&quot;ArcadePhysics&quot;];

            //can&#x27;t separate two immovable objects
            var obj1immovable: boolean = phys1.immovable;
            var obj2immovable: boolean = phys2.immovable;
            if (obj1immovable &amp;&amp; obj2immovable)
                return false;

            //removed tilemaps

            //First, get the two object deltas
            var overlap: number = 0;

            var obj1delta: number = phys1.transform.y - phys1.last.y;

            var obj2delta: number = phys2.transform.y - phys2.last.y;
            if (obj1delta != obj2delta) {
                //Check if the Y hulls actually overlap
                var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
                var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys1.transform.x, phys1.transform.y - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.width, phys1.height + obj1deltaAbs);
                var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys2.transform.x, phys2.transform.y - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.width, phys2.height + obj2deltaAbs);
                if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {
                    var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                    //If they did overlap (and can), figure out by how much and flip the corresponding flags
                    if (obj1delta &gt; obj2delta) {
                        overlap = phys1.transform.y + phys1.height - phys2.transform.y;
                        if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.DOWN) || !(phys2.allowCollisions &amp; ArcadePhysics.UP)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.DOWN;
                            phys2.touching |= ArcadePhysics.UP;
                        }
                    }
                    else if (obj1delta &lt; obj2delta) {
                        overlap = phys1.transform.y - phys2.height - phys2.transform.y;
                        if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.UP) || !(phys2.allowCollisions &amp; ArcadePhysics.DOWN)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.UP;
                            phys2.touching |= ArcadePhysics.DOWN;
                        }
                    }
                }
            }

            //Then adjust their positions and velocities accordingly (if there was any overlap)
            if (overlap != 0) {
                var obj1v: number = phys1.velocity.y;
                var obj2v: number = phys2.velocity.y;

                if (!obj1immovable &amp;&amp; !obj2immovable) {
                    overlap *= 0.5;
                    phys1.transform.y = phys1.transform.y - overlap;
                    phys2.transform.y = phys2.transform.y + overlap;

                    var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                    var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                    var average: number = (obj1velocity + obj2velocity) * 0.5;
                    obj1velocity -= average;
                    obj2velocity -= average;
                    phys1.velocity.y = average + obj1velocity * phys1.elasticity;
                    phys2.velocity.y = average + obj2velocity * phys2.elasticity;
                }
                else if (!obj1immovable) {
                    phys1.transform.y = phys1.transform.y - overlap;
                    phys1.velocity.y = obj2v - obj1v * phys1.elasticity;
                    //This is special case code that handles cases like horizontal moving platforms you can ride
                    if (object2.active &amp;&amp; phys2.moves &amp;&amp; (obj1delta &gt; obj2delta))
                        phys1.transform.x = phys1.transform.x + object2.transform.x - phys2.last.x; 
                }
                else if (!obj2immovable) {
                    phys2.transform.y = phys2.transform.y + overlap;
                    phys2.velocity.y = obj1v - obj2v * phys2.elasticity;
                    //This is special case code that handles cases like horizontal moving platforms you can ride
                    if (object1.active &amp;&amp; phys1.moves &amp;&amp; (obj1delta &lt; obj2delta))
                        phys2.transform.x = phys2.transform.x + object1.transform.x - phys1.last.x; 
                }
                return true;
            }
            else
                return false;

        }

        /**
        * CURRENTLY UNTESTED...
        */
        public static computeVelocity(velocity: number, acceleration: number = 0, drag: number = 0, max: number = 10000) {
            /*
            if (acceleration != 0)
                velocity += acceleration * ArcadePhysics.updateInterval;
            else if (drag != 0) {
                drag = drag * ArcadePhysics.updateInterval;
                if (velocity - drag &gt; 0)
                    velocity = velocity - drag;
                else if (velocity + drag &lt; 0)
                    velocity += drag;
                else
                    velocity = 0;
            }
            if ((velocity != 0) &amp;&amp; (max != 10000)) {
                if (velocity &gt; max)
                    velocity = max;
                else if (velocity &lt; -max)
                    velocity = -max;
            }
            return velocity;*/
        }


        ////////Instance Functions/////////

        /**
        * A method to check to see if the parent of this physics component overlaps with another Kiwi.Entity.
        * 
        * @method overlaps
        * @param { Kiwi.Entity } gameObject
        * @param { boolean } seperateObjects
        * @return { boolean }
        */
        public overlaps(gameObject: Entity, separateObjects: boolean = false): boolean {
            
            var objTransform: Kiwi.Geom.Transform = gameObject.transform;

            var result: boolean = (objTransform.x + gameObject.width &gt; this.transform.x) &amp;&amp; (objTransform.x &lt; this.transform.x + this.width) &amp;&amp;
                (objTransform.y + gameObject.height &gt; this.transform.y) &amp;&amp; (objTransform.y &lt; this.transform.y + this.height);

            if (result &amp;&amp; separateObjects) {
                ArcadePhysics.separate(this._parent, gameObject);
            }

            if (result &amp;&amp; this._callbackFunction !== null &amp;&amp; this._callbackContext !== null) {
                this._callbackFunction.call(this._callbackContext, this._parent, gameObject);
            }

            return result;

        }

        /**
        * A method to check to see if the parent of this physics component overlaps with another group of objects
        * 
        * @method overlaps
        * @param { Kiwi.Group } gameObject
        * @param { boolean } seperateObjects
        * @return { boolean }
        */
        public overlapsGroup(group: any, separateObjects: boolean = false): boolean {
            
            //if the group is a Kiwi.Group
            var results: boolean = false;
            
            if (group.childType !== undefined &amp;&amp; group.childType() === Kiwi.GROUP) {

                for (var i = 0; i &lt; group.members.length; i++) {

                    if (group.members[i].childType() === Kiwi.GROUP) {
                        //recursively check overlap
                        this.overlapsGroup(&lt;Kiwi.Group&gt;group.members[i], separateObjects);

                    } else {
                        //otherwise its an entity

                        if (this.overlaps(&lt;Kiwi.Entity&gt;group.members[i], separateObjects)) {
                            if (this._callbackContext !== null &amp;&amp; this._callbackFunction !== null)
                                this._callbackFunction.call(this._callbackContext, this._parent, group.members[i]);
                            results = true;
                        }

                    }
                }
            } else if (Object.prototype.toString.call(group) == &#x27;[object Array]&#x27;) {
                //loop through the array

                for (var i = 0; i &lt; group.length; i++) {
                    if (group[i].childType !== undefined &amp;&amp; group[i].childType() === Kiwi.ENTITY) {
                        if (this.overlaps(&lt;Kiwi.Entity&gt;group[i], separateObjects)) {
                            this._callbackFunction.call(this._callbackContext, this._parent, group[i]);
                            results = true;
                        }
                    }
                }

            } 

            return results;

        }

        /**
        * Updates the motion...
        * UNTESTED.
        */
        public updateMotion() {
            /*
            var delta: number;
            var velocityDelta: number;
            
            
            velocityDelta = (ArcadePhysics.computeVelocity(this.angularVelocity, this.angularAcceleration, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
            this.angularVelocity += velocityDelta;
            this.angle += this.angularVelocity * ArcadePhysics.updateInterval;
            this.angularVelocity += velocityDelta;
           
            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.x, this.acceleration.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
            this.velocity.x += velocityDelta;
            delta = this.velocity.x * ArcadePhysics.updateInterval;
            this.velocity.x += velocityDelta;
            this.transform.x = this.transform.x + delta;

            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.y, this.acceleration.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
            this.velocity.y += velocityDelta;
            delta = this.velocity.y * ArcadePhysics.updateInterval;
            this.velocity.y += velocityDelta;
            this.transform.y = this.transform.y + delta;
        */
        }
    
        /**
        * Sets up a callback function that will run when this object overlaps with another.
        * 
        * @method setCallback
        * @param {function} callbackFunction
        * @param {any} callbackContext
        */
        public setCallback(callbackFunction, callbackContext) {
            
            this._callbackFunction = callbackFunction;
            this._callbackContext = callbackContext;

        }

        /**
        * Returns the parent of this entity. Mainly used for executing callbacks.
        *
        * @method parent
        * @return {Kiwi.Entity}
        */
        public parent() {
            return this._parent;
        }

        /**
        * The Update loop of the physics component
        */
        public update() {

            //Flixel preupdate
            this.last.x = this.transform.x;
            this.last.y = this.transform.y;

            //update width/height. Needs to find better spot
            this.width = this._parent.width;
            this.height = this._parent.height;

            //Flixel postupdate
            if (this.moves)
                this.updateMotion();

            this.wasTouching = this.touching;
            this.touching = ArcadePhysics.NONE;


        }

        public destroy() {
            super.destroy();

            delete this.transform;
            delete this._parent;
            delete this._callbackContext;
            delete this._callbackFunction;
        }
        

    }

}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
